# data sharding

## why

- With limited CPU, storage capacity, and memory, query throughput and response times limit for single machine
- single node data into a cluster of database nodes

## vertical sharding

- split table by column

## horizontally partitioning

- split table by rows

## manual sharding

- know how data is distributed
- Disproportionate distribution of data, unbalanced

## auto sharding

- hash sharding, 10%4
- range sharding
- geo partitioning

[reference](https://www.cnblogs.com/langtianya/p/4997768.html)

### 每个表对应的三个文件

- .MYD 数据文件
- .MYI 索引文件
- .frm 表结构文件

### merge 存储引擎

总表-分表

### 性能体现

1. 分表后，单表的并发能力提高了，磁盘 I/O 性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同 的查询，将并发压力分到不同的小表里面。磁盘 I/O 性能怎么搞高了呢，本来一个非常大的.MYD 文件现在也分摊到各个小表的.MYD 中去了。
2. mysql 提出了分区的概念，我觉得就想突破磁盘 I/O 瓶颈，想提高磁盘的读写能力，来增加 mysql 性能。
   在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高 mysql 并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高 mysql 性能的目的。

### 实现难度

1. 分表的方法有很多，用 merge 来分表，是最简单的一种方式。这种方式根分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。
2. 分区实现是比较简单的，建立分区表，根建平常的表没什么区别，并且对开代码端来说是透明的。

### 分表 vs 分库

从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上.

数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，一台服务器的资源（CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈

### 实现

如果你的单机性能很低了，那可以尝试分库。分库，业务透明，在物理实现上分成多个服务器，不同的分库在不同服务器上。分区可以把表分到不同的硬盘上，但不能分配到不同服务器上。一台机器的性能是有限制的，用分库可以解决单台服务器性能不够，或者成本过高问题。  
当分区之后，表还是很大，处理不过来，这时候可以用分库。  
orderid,userid,ordertime,.....  
userid%4=0，用分库 1  
userid%4=1，用分库 2  
userid%4=2, 用分库 3  
userid%4=3，用分库 4  
上面这个就是一个简单的分库路由，根据 userid 选择分库，即不同的服务器

1

#### 垂直切分

即将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。

#### 水平切分

当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列、按性别、按省，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的 userDB 中的用户数据表中，每一个表的数据量都很大，就可以把 userDB 切分为结构相同的多个 userDB：part0DB、part1DB 等，再将 userDB 上的用户数据表 userTable，切分为很多 userTable：userTable0、userTable1 等，然后将这些表按照一定的规则存储到多个 userDB 上。

### 存在的问题

1. 事务问题
   在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
2. 跨库跨表的 join 问题
   在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法 join 位于不同分库的表，也无法 join 分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。
3. 额外的数据管理负担和数据运算压力。
   额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表 userTable，业务要求查出成绩最好的 100 位，在进行分表之前，只需一个 order by 语句就可以搞定，但是在进行分表之后，将需要 n 个 order by 语句，分别查出每一个分表的前 100 名用户数据，然后再对这些数据进行合并计算，才能得出结果。
